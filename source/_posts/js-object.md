---
title: js-object
date: 2018-09-22 23:44:52
categories:
    - front-end
tags:
    - JavaScript
---

# JavaScript的内存机制及按值传递

JavaScript是一门轻级的编程语言, 我之前也用过C++和Java, 相比起来JavaScript是一门年轻简约的编程语言, 但是我很看好这门语言, 我记得之前看过一个大牛说现在的前端开发是黎明前的黑暗, 在数年之内必定会清晰明朗起来. 自己深表赞同, JavaScript现在的确是有很多的缺陷, 相比较起来它的依赖库也不如java那般丰富, 但是它一个最大的优点(个人认为)就是它的轻量级, 你仅仅需要一个浏览器(或者Node环境, 但是Node其实也是基于Chrome的V8引擎), 他就能完成自己所有的工作, 我坚信随着各种标准的制定以及已经走在探索路上的前端开发师们能够很快为JavaScript带来它起飞的春天.

上面是我的个人希冀, 说到这篇文章, 主要是记录一下JavaScript的内存机制以及按值传递规则, 因为我在JavaScript的开发过程中会不由自主的把它和我也使用过的C++和Java进行比较, 我认为编程语言是互通的, 但是它们在某些细节上的处理有所不同, 则正是我们需要去注意的.

<!-- more -->

## 内存机制

在JavaScript中有`堆`和`栈`两个存储概念, `堆`是用来存储`Object`型数据的 ,`栈`是用来存储6种基本数据类型(分别是`null`, `undefined`, `boolean`, `number`, `string`和ES6中新引入的`symbol`), 对于我们平时使用的数组`Array`其实是`Object`的继承而已, 可以使用`typeof`运算符查看一个数据的类型, 例如`typeof []`就会输出`object`, 另外一个比较特别的就是函数类型, 函数类型的`typeof`输出的是`function`, 但是函数其实也是存储在`堆`中的, 而且可以认为是以字符串的形式存储的.

### 为什么有`堆`和`栈`之分

与垃圾回收机制有关，为了使程序运行时占用的内存最小。
当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的;
当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复理由(因为对象的创建成本通常比较大),这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(方法的参数传递时很常见),则这个对象依然不会被销毁,只有当一个对象没有任何引用变量引用它时,系统的垃圾回收机制才会在核实的时候回收它。  --[参考](https://segmentfault.com/a/1190000016322927#articleHeader3)

在我们知道了JavaScript中的对象是如何存储的之后, 我们就要看一下当我们生成一个变量的时候到底发生了什么.

## 生成变量

假如我们生成的是一个存储基本数据类型的变量, 例如`let a = 3`或者`let b = 'hello'`, 那么有如下两步:

1. 在`栈`中直接开辟出一小块空间
2. 把你赋予的数据(`3`或者`hello`)存储到这个`栈`空间中

也就是说数据是直接存储在`栈`中, 但是当我们生成的是一个存储了对象类型的变量, 例如`let c = {name: 'krics'}`, 那么这个时候过程就要复杂一些:

1. 在`堆`中开辟一块空间
2. 把你赋予的数据`{name: 'krics'}`存储到这个`堆`空间中
3. 在`栈`中开辟一小块空间
4. 将之前存储了对象数据的`堆`空间的地址(指针形式)存储到现在刚刚开辟的这个`栈`空间中

所以我们真正的数据其实是存储在`堆`中的, 我们拿到的`c`变量里面只是存储了数据的真实地址, 当我们需要访问或者操作数据的时候, JavaScript就会根据这个地址去找到对应的数据, 然后访问或者操作它.

## 值的拷贝

我们需要永远记住最关键的一点: **JavaScript中只存在按值传递!!!**
不同于C++中或者Java中经常出现的指针操作, 在JavaScript中不会出现按引用传递, JavaScript永远只操作一个变量最直接的值, 并不会考虑这个值是基本数据类型还是一个指针, 因为如果是指针, 也并不会去按照指针找到具体的数据, 然后拷贝数据什么的, 是指针, 那我就传递这个指针的字面值, 简单粗暴明了.

例如:

```JavaScript
let a = 'hello';
let b = a;

b = 'yell';

console.log(a); // => 'hello'
console.log(b); // => 'yell'
```

这里发生的故事是:

1. 在`栈`中开辟了一个空间叫`a`, 然后在`a`里面存入了一个字符串`hello`
2. 在`栈`中开辟了一个空间叫`b`, 然后在`b`里面存入了一个字符串`hello`(`按值传递`, 值是`hello`, 那么就再存一个`hello`)
3. 修改`栈`中`b`的值为`yell`
4. 输出`a`的值, 没被改变过, 所以输出`hello`
5. 输出`b`的值, 先是`hello`, 后来被改成了`yell`, 那么最后输出的就是`yell`

那么我们举一个对象的例子又如何呢?

```JavaScript
let c = {name: 'krics'};
let d = c;

c.name = 'leo';
console.log(d.name); // => 'leo'

d.name = 'troy';
console.log(c.name); // => 'troy'
```

这里发生的故事是:

1. 先在`栈`中开辟一块空间名字叫做`c`, 然后在`堆`中开辟一块空间, 存入数据`{name: 'krics'}`, 然后把`堆`中刚存储的数据的地址存到`c`中
2. 在`栈`中开辟一块空间名字叫做`d`, 然后把`c`中存储的值也就是`{name: 'krics'}`的地址在`d`中再存储一份
3. 将`c`指向的对象中的`name`的值改为字符串`leo`,
4. `d`和`c`指向的是同一个对象, 所以第三步中通过`c`改了`name`的值以后, 通过`d`访问这个`name`时得到的也是改变后的值`leo`
5. 第五和第六步与第三和第四步做法类似

这里给出一个很有趣的思考题:

```JavaScript
var a = {n:1};
var b = a;
a.x = a = {n:2};

console.log(a.x); // => 想想这里 a.x 的值是什么
console.log(b.x); // => 想想这里 b.x 的值是什么
```

这里给个提示, 上面主要涉及到三个细节点, 一是JavaScript中正常运算顺序为从右到左, 二是`.`点运算符的优先级高于`=`等号, 三就是我们之前讨论过的对象如何赋值问题, 答案可以参考[luoqua的文章](https://segmentfault.com/a/1190000016322927#articleHeader5)

最后我仍然要强调一点: **JavaScript中只存在按值传递!!!**(可以参考<JavaScript高级程序设计>一书中第四章'变量. 作用域和内存问题')