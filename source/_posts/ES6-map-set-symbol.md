---
title: ES6-map-set-symbol
date: 2019-01-18 10:23:08
subtitle: ES6中新的数据类型
categories:
  - front-end
tags:
  - ES6
---

# ES6中新的数据类型

在ES6里面引入了一些新的数据类型, 包括 `Map` / `Set` / `Symbol` 等等, 这里了解一下他们的用法和使用场景.
<!-- more -->

## `Map`

我们之前存储键值对形式的数据使用的都是`{}`这样的`Object`对象, 但是很大的一个确定是键只能使用字符串, 即使传入的不是字符串内容, 内部也会将传入的值转换为字符串类型来存储, ES6中推出的`Map`可以解决这个局限性, `Map`中存储的键和值都可以是任意的类型, 是一种更完善的 Hash 结构实现.

### `Map`相关API

1. `new Map()`构造函数

```js
// 构造函数
const a = new Map();

// 或者我们也可以传入数组作为构造函数的参数来生成一个 Map
const b = new Map([
  ['name', 'krics'],
  ['gender', 'male']
]); // => {"name" => "krics", "gender" => "male"}
```

关于传入数组作为构造函数的参数然后生成 Map 时所发生的事情可以按照如下过程理解, 实际上会循环数组本身, 然后对每个子元素取出它的第一个值作为key, 第二个值作为value, 赋值到空的 Map 中, 注意是只会用到子元素的前两个值, 如果子元素中有更多的值, 那么并不会被赋值到 Map 中, 会被忽略掉.

```js
const arr = [
  ['name', 'krics'],
  ['gender', 'male']
];
const b = new Map();

arr.forEach(([key, value]) => b.set(key, value));
```

除了数组之外, 任何具有 Iterator 接口、且每个成员都是多个元素的数组的数据结构的都可以作为 Map 构造函数的参数. 例如使用 Set 类型数据作为参数:

```js
const set = new Set([
  ['name', 'krics'],
  ['gender', 'male']
]);
const c = new Map(set); // => {"name" => "krics", "gender" => "male"}
```

2. `Map.set(key, value)`添加值
  参数`key`和`value`都可以是任意类型的, 并且执行后会返回当前`Map`对象, 所以可以链式调用`Map.set(key1, value1).set(key2, value2)`.
  `key`实际是和内存地址绑定的, 也就是说`Map.set({}, 1).set({}, 2)`会添加两个键值对到对象中, 因为两次使用的`{}`都会有各自的地址, 不是同一个对象, 如果对同一个键多次赋值, 最后一次会覆盖之前的值.
  对于键值是否相同的判断可以大致理解为`===`判断, 唯一不同的是`===`认为`NaN`和`NaN`不等, 但是在`Map`中会被认为相同, 作为同一个键.
3. `Map.get(key)`取值
  返回对应的值, 如果`Map`对象中没有这个键, 则返回`undefined`
4. `Map.has(key)`判断是否有该键
  有则返回`true`否则返回`false`
5. `Map.delete(key)`删除某个键值对
  删除成功返回`true`否则返回`false`
6. `Map.clear()`清除所有的键值对
  清除所有的键值对, 没有返回值
7. `Map.size`当前键值对的数量
  返回当前`Map`对象中的键值对数量

8. 遍历`Map`

  - `Map.keys()` 返回键名的遍历器
  - `Map.values()` 返回键值的遍历器
  - `Map.entries()` 返回所有成员的遍历器
  - `Map.forEach()` 遍历 Map 的所有成员

  需要特别注意的是，Map 的遍历顺序就是插入顺序.

### `Map`与其他数据类型的转换

`Map`转为数组, 由于扩展运算符(`...`)底层实际调用的是数据结构的`Iterator`接口,因此只要具有`Iterator`接口的对象，都可以使用扩展运算符, `Map`也不例外.

```js
// 这里先使用一个数组生成了一个 map, 最后又使用生成的 map 转换得到了原来的数组
const d = new Map([
  ['name', 'krics'],
  ['gender', 'male']
]);

const arr = [...d]; // => [ ["name", "krics"], ["gender", "male"] ]
```

### 弱化的`WeakMap`

`WeakMap`和`Map`的结构与用法基本相似, 不过存在一些比较重要的区别.

- `WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名
- `WeakMap`不能遍历, 也就是没有`keys()`, `values()`, `entries()`方法, 并且也没有`size`属性和`clear()`方法, 它保留的只有四个方法`set()`, `get()`, `has()`和`delete()`

之所以特意设计`WeakMap`这个类型, 实际是为了解决浏览器的内存释放问题, 浏览器内存的垃圾回收机制中其中一种叫`引用计数法`, 当一个对象的被引用次数大于等于1的时候, 浏览器是不会去清除回收这个对象的, 在老旧的IE中经常出现代码中引用了某个`DOM`元素, 但是由于当时的底层机制, 这个引用无法被清除, 导致`DOM`对象一直留存在内存中, 最后可能就会拖垮浏览器(现代的浏览器不会这样了), 所以考虑到有时候我们并不需要一个对象一直被引用导致内存空间无法被回收, 然后设计了`WeakMap`这个类型.

`WeakMap`中的键名所引用的对象是不会被`引用计数法`算作是引用的, 也就是说在内存回收的时候, 如果别的地方都没有使用这个对象了, 即使在`WeakMap`中有键名是在引用这个对象的, 那么浏览器也还是会回收这个对象, 释放掉它占用的内存. 需要注意的是这个弱化的过程只是弱化了键名的引用, 键值如果引用了某个对象, 那个对象是会被算做引用`+1`的.

一旦键名引用的对象被回收掉了, 那么`WeakMap`中对应的这一项也会被自动清除, 不需要我们手动`delete()`删除这一项. 一个典型应用场景是，在网页的`DOM`元素上添加数据，就可以使用`WeakMap`结构。当该`DOM`元素被清除，其所对应的`WeakMap`记录就会自动被移除. 更详细的例子可以查看[这里](http://es6.ruanyifeng.com/#docs/set-map).

## `Set`

ES6 为了改善之前一直使用`{}`来创建键值对形式的数据而新增了`Map`, 同样为了改善数组形式数据的使用而新增了`Set`, `Set`类似于数组, 但是其中的值都是唯一的, 不存在重复.(不会重复这一点可以用来去重或者交集并集等等)

### `Set`相关API

1. `Set`本身是一个构造函数, 参数可以是数组或者其它有`iterable`接口的数据. 例如:

```js
const a = new Set();

const b = new Set([1, 2, 3, 2]); // a => 1, 2, 3

const c = new Set('aabaa'); // c => a, b
```

`Array.from()`可以把`Set`转为普通数据.

2. 其它api

2.1 `add()`: 添加数据
2.2 `delete()`: 删除数据
2.3 `clear()`: 删除所有数据
2.4 `has()`: 判断是否有某个数据
2.5 `size`: 返回数据数目
2.6 `keys()`: 遍历键(与值实际相等)
2.7 `values()`: 遍历值
2.8 `entries()` 遍历键值对(键与值相等)
2.9 `forEach()`: 遍历值

### `WeakSet`

ES6 同样也为`Set`提供了`WeakSet`类型, 与`WeakMap`十分相似, `WeakSet`中的值只能是对象, 不能是其他类型的值, 同样也是不计算引用次数的. 使用时可以用`new WeakSet()`来构建, 其他api与`Set`一致, 不过出于跟`WeakMap`相同的原因, 也是不能遍历的.

